# Краткий гайд по TanStack Query (vue-query)

## Основные утилиты

### useQuery

- Получение данных с сервера.
- Автоматическое кеширование результата.
- Управление состояниями загрузки, ошибок и успеха.

### useMutation

- Изменение данных (POST, PUT, DELETE).
- Не кеширует результат, но позволяет обновлять связанные запросы через `invalidateQueries`.

---

## Ключевые параметры

| Параметр              | Описание                                                                  |
| --------------------- | ------------------------------------------------------------------------- |
| **queryKey**          | Уникальный ключ для каждого запроса. Используется для кеширования данных. |
| **queryFn**           | Функция, возвращающая Promise с данными (обычно через axios или fetch).   |
| **staleTime**         | Время (мс), в течение которого данные считаются "свежими".                |
| **refetch**           | Вручную вызывает повторный запрос для получения свежих данных.            |
| **invalidateQueries** | Позволяет вручную обновить (рефетчить) данные по queryKey после мутаций.  |

---

## Как работает кеширование

- При вызове `useQuery` с определённым `queryKey`, TanStack Query сохраняет результат запроса в памяти (кеш).
- Если другой компонент запрашивает данные с тем же `queryKey`, библиотека возвращает закешированные данные, не делая новый запрос (пока данные считаются свежими).

### staleTime

- Это время (в миллисекундах), в течение которого данные считаются актуальными.
- Например, если `staleTime = 60_000`, то в течение минуты повторные запросы с тем же `queryKey` будут возвращать кеш, а не делать новый запрос.

### Когда кеш обновляется

- Истёк `staleTime` и компонент снова запрашивает данные.
- Вручную вызвано `invalidateQueries` для `queryKey` (например, после мутации).
- Изменился `queryKey` (например, изменились параметры фильтрации).
- Компонент размонтировался и снова смонтировался.

---

## Преимущества кеширования

- Меньше запросов к серверу.
- Быстрый доступ к данным.
- Автоматическое обновление при необходимости.

---

## Пример использования

```typescript
const { data, isLoading } = useQuery({
  queryKey: ['products', { category: 'sneakers' }],
  queryFn: () => axios.get('/api/products?sneakers').then((res) => res.data),
  staleTime: 60 * 1000, // данные считаются свежими 1 минуту
})
```

- Если другой компонент вызовет `useQuery` с таким же `queryKey` — он получит данные из кеша.
- Если вызвать `invalidateQueries({ queryKey: ['products'] })` — данные будут обновлены.

---

## Как работает invalidateQueries

`invalidateQueries` работает по принципу "начало совпадает" (partial match):

```typescript
queryClient.invalidateQueries({ queryKey: ['products'] })
```

Это затронет все запросы, чей `queryKey` начинается с `'products'`, например:

- `['products']`
- `['products', { category: 'sneakers' }]`
- `['products', { category: 'boots' }]`

---

## Итог

TanStack Query автоматически управляет кешем, состояниями и повторными запросами.  
Вы контролируете, когда и как обновлять данные через `queryKey`, `staleTime`, `invalidateQueries` и `refetch`.  
Это делает работу с асинхронными запросами удобной, быстрой и надёжной.
